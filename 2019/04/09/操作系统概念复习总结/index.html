<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="uuweidy" />



<meta name="description" content="本人对于大学期间《操作系统》课程的所做复习时的一些总结，包含概述和进程管理部分 完成">
<meta name="keywords" content="学习笔记,操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统概念复习总结">
<meta property="og:url" content="http://uuweidy.github.io/2019/04/09/操作系统概念复习总结/index.html">
<meta property="og:site_name" content="uuweidy&#39;s world">
<meta property="og:description" content="本人对于大学期间《操作系统》课程的所做复习时的一些总结，包含概述和进程管理部分 完成">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdn.net/20170820104536564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWljaGVuZzc3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2019-05-14T12:53:08.574Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统概念复习总结">
<meta name="twitter:description" content="本人对于大学期间《操作系统》课程的所做复习时的一些总结，包含概述和进程管理部分 完成">
<meta name="twitter:image" content="https://img-blog.csdn.net/20170820104536564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWljaGVuZzc3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="uuweidy&#39;s world" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>操作系统概念复习总结 | uuweidy&#39;s world</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/author.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">uuweidy</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/随笔">随笔</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:975397847@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/uuweidy" title="GitHub"></a>
                            
                                <a class="fa 网易云音乐" href="https://music.163.com/#/user/home?id=335297551" title="网易云音乐"></a>
                            
                                <a class="fa bilibili" href="https://space.bilibili.com/4474041" title="bilibili"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Andriod-Studio/">Andriod Studio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习笔记/">学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安装配置/">安装配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日常生活/">日常生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/胡言乱语/">胡言乱语</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">uuweidy</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/author.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">uuweidy</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/随笔">随笔</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:975397847@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/uuweidy" title="GitHub"></a>
                            
                                <a class="fa 网易云音乐" target="_blank" href="https://music.163.com/#/user/home?id=335297551" title="网易云音乐"></a>
                            
                                <a class="fa bilibili" target="_blank" href="https://space.bilibili.com/4474041" title="bilibili"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-操作系统概念复习总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/04/09/操作系统概念复习总结/" class="article-date">
      <time datetime="2019-04-09T02:03:11.000Z" itemprop="datePublished">2019-04-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      操作系统概念复习总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习笔记/">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>本人对于大学期间《操作系统》课程的所做复习时的一些总结，包含概述和进程管理部分</p>
<p>完成</p>
</blockquote>
<a id="more"></a>
<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><p>操作系统是<strong>资源分配器</strong>和<strong>控制程序</strong></p>
<h2 id="计算机系统体系结构"><a href="#计算机系统体系结构" class="headerlink" title="计算机系统体系结构"></a>计算机系统体系结构</h2><h3 id="单处理器系统"><a href="#单处理器系统" class="headerlink" title="单处理器系统"></a>单处理器系统</h3><p>有一个主CPU执行一个通用指令集，其他专用处理器运行一个受限的指令集，并不运行用户进程</p>
<h3 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h3><p>有多个紧密通信的CPU，共享计算机总线</p>
<p>有三个主要优点：</p>
<ul>
<li>增加吞吐量</li>
<li>规模经济</li>
<li>增加可靠性</li>
</ul>
<h4 id="非对称多处理"><a href="#非对称多处理" class="headerlink" title="非对称多处理"></a>非对称多处理</h4><p>每个处理器有各自特定的任务，主处理器调度从处理器并安排工作。</p>
<h4 id="对称多处理（SMP）"><a href="#对称多处理（SMP）" class="headerlink" title="对称多处理（SMP）"></a>对称多处理（SMP）</h4><h3 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h3><p>集群计算机共享存储并通过局域网络连接或者更快的内部连接。</p>
<p>通常用来提供<strong>高可用性</strong>服务，当集群中的一个或多个系统出错时，服务仍然继续。</p>
<p>可以是对称的，也可以是非对称的。<strong>非对称集群</strong>中一台机器处于热备份模式，而另一台运行应用程序。热备份主机只监视服务器，当服务器失效时热备份主机会成为现行服务器。<strong>对称集群</strong>中多个主机都运行应用程序，它们互相监视。</p>
<h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><ol>
<li>简单结构<ol>
<li>较小、简单且功能有限</li>
<li>没有很好地区分接口和功能层次</li>
</ol>
</li>
<li>分层方法<ol>
<li>系统分为若干层，每个层由数据结构和一组可为上层所调用的子程序集合所组成</li>
<li>构造和调试的简单化</li>
<li>对层的详细定义困难</li>
<li>效率较低</li>
</ol>
</li>
<li>微内核<ol>
<li>把所有非基本部分从内核移走并实现为系统程序或用户程序</li>
<li>使客户程序和运行在用户空间的各种服务之间进行通信。通信以消息传递形式提供</li>
<li>便于扩充操作系统</li>
<li>提供了更好的安全性和可靠性</li>
<li>很容易从一种硬件平台设计移植到另一种硬件平台设计</li>
<li>系统功能总开销增加导致了系统性能的下降</li>
</ol>
</li>
<li>模块<ol>
<li>用面向对象编程技术来生成模块化的内核，使用动态加载模块。</li>
<li>允许内核提供核心服务，也能动态地实现特定的功能。</li>
<li>由于不需要调用消息传递来通信，更为高效</li>
</ol>
</li>
</ol>
<h2 id="操作系统服务"><a href="#操作系统服务" class="headerlink" title="操作系统服务"></a>操作系统服务</h2><p>用户与操作系统的交互方式：</p>
<ul>
<li>命令行</li>
<li>系统调用</li>
<li>图形界面</li>
</ul>
<p>一组操作系统服务提供对用户很有用的函数：</p>
<ul>
<li>用户界面</li>
<li>程序执行</li>
<li>I/O操作</li>
<li>文件系统操作</li>
<li>通信</li>
<li>错误检测</li>
</ul>
<p>另一组操作系统函数确保系统本身高效运行：</p>
<ul>
<li>资源分配</li>
<li>统计</li>
<li>保护和安全</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>提供了操作系统提供的有效服务界面。</p>
<p>向操作系统传递参数的三种方法：</p>
<ol>
<li>寄存器</li>
<li>内存的块</li>
<li>堆栈</li>
</ol>
<blockquote>
<p> <em>堆和栈的区别</em></p>
<ul>
<li>数据结构类型不同（但是此处的堆和数据结构中的堆<strong>不同</strong>！）</li>
<li>堆由程序员申请和释放空间大小、栈由系统分配和回收</li>
</ul>
</blockquote>
<h3 id="系统调用类型"><a href="#系统调用类型" class="headerlink" title="系统调用类型*"></a>系统调用类型*</h3><ul>
<li><p>进程控制</p>
</li>
<li><p>文件管理</p>
</li>
<li><p>设备管理</p>
</li>
<li><p>信息维护</p>
</li>
<li><p>通信</p>
</li>
</ul>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>将单个计算机的硬件抽象为几个不同的执行部件，从而造成一种每个独立的执行环境都在自己的计算机上运行的幻觉。</p>
<h3 id="创建虚拟机的原因"><a href="#创建虚拟机的原因" class="headerlink" title="创建虚拟机的原因"></a>创建虚拟机的原因</h3><ul>
<li>在并行运行几个不同的执行环境时能够共享相同的硬件</li>
<li>能够运行原来机器所具有的任何操作系统或软件包</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>每个虚拟机完全独立于其他虚拟机，因此没有安全问题</li>
<li>用于研究和开发操作系统</li>
</ol>
<h1 id="进程（CPU资源分配的基本单元）"><a href="#进程（CPU资源分配的基本单元）" class="headerlink" title="进程（CPU资源分配的基本单元）"></a>进程（CPU资源分配的基本单元）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程包括：</p>
<ul>
<li>文本段（程序代码）</li>
<li>程序计数器和寄存器</li>
<li>堆栈段</li>
<li>数据段</li>
<li>堆</li>
<li>全局段</li>
<li>文字常量段</li>
</ul>
<p>程序是被动实体，是静态的；进程是活动实体，是动态的</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>每个进程可能处于下列状态之一：</p>
<ul>
<li>新的</li>
<li>运行</li>
<li>等待</li>
<li>就绪</li>
<li>终止</li>
<li>就绪挂起</li>
</ul>
<p>一次只有一个进程可在一个处理器上运行，但是多个进程可处于就绪或等待状态。</p>
<p><img src="https://img-blog.csdn.net/20170820104536564?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWljaGVuZzc3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="进程状态图"></p>
<h3 id="进程控制块（PCB，进程存在的唯一标志）"><a href="#进程控制块（PCB，进程存在的唯一标志）" class="headerlink" title="进程控制块（PCB，进程存在的唯一标志）"></a>进程控制块（PCB，进程存在的唯一标志）</h3><p>包含许多与一个特定进程相关的信息。</p>
<ul>
<li>进程状态</li>
<li>程序计数器：表示进程要执行的下个指令的地址</li>
<li>CPU寄存器</li>
<li>CPU调度信息</li>
<li>内存管理信息</li>
<li>记账信息</li>
<li>I/O状态信息</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程*"></a>线程*</h3><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>选择一个可用的进程到CPU上执行，使CPU利用率达到最大化。</p>
<h3 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h3><p>作业队列中包括系统中的所有进程，驻留在内存中就绪的、等待运行的进程保存在就绪队列中。</p>
<p>等待特定I/O设备的进程列表称为设备队列，每个设备都有自己的设备队列。</p>
<h3 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h3><p>对于批处理系统，进程被放到缓冲池中，<strong>长期调度程序</strong>或<strong>作业调度程序</strong>从该池中选择进程，并装入内存以准备执行。<strong>短期调度程序</strong>或<strong>CPU调度程序</strong>从准备执行的进程中选择进程分配CPU。</p>
<p>长期调度程序和短期调度程序的区别就是执行的频率。</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>当发生一个中断时，系统需要保存当前运行在CPU中进程的上下文，从而在其处理完成后能恢复上下文。</p>
<p>通常通过一个状态保存来保存CPU当前状态，之后执行一个状态恢复重新开始运行。</p>
<p>将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为上下文切换。</p>
<h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>进程在执行过程中通过创建进程系统调用创建多个新进程。创建进程称为父进程，新进程称为子进程。每个新进程可以再创建其他进程，从而形成了进程树。</p>
<p>init进程是所有用户进程的根进程。</p>
<p>进程标识符（pid）是唯一的操作系统用来识别进程的标志。</p>
<p>在创建子进程的时候，子进程可能从操作系统那里直接获得资源，也可能只从其父进程那里获得资源。</p>
<p>父进程可能与子进程并发执行（宏观并行，微观串行），也可能父进程等待子进程执行。</p>
<blockquote>
<p>fork()函数：</p>
<ul>
<li><p>一次调用，两次返回。父进程返回子进程的pid，子进程返回0</p>
</li>
<li><p>同时复制父进程的缓冲区。</p>
</li>
<li>写时拷贝：刚产生时共用一部分空间，对子进程操作时才申请新的资源。</li>
</ul>
</blockquote>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ul>
<li>子进程使用了超过它所分配到的资源</li>
<li>分配给子进程的任务已不再需要</li>
<li>父进程退出</li>
</ul>
<p>级联终止：父进程终止时所有子进程也终止</p>
<p>也可以使所有子进程以init进程作为父进程</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul>
<li>信息共享</li>
<li>提高运算速度</li>
<li>模块化</li>
<li>方便</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>向共享内存区域读或写入数据来交换信息。</p>
<p>需要程序员明确编写访问和操作共享内存的代码</p>
<p>更快（仅在建立共享内存区时需要系统调用，建立之后所有的访问都是常规的内存访问）</p>
<p>典型：<strong>生产者-消费者问题</strong></p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>通过在协作进程间交换信息来实现通信。</p>
<p>由操作系统提供机制</p>
<p>对于交换少量数据有效，不需要避免冲突。</p>
<p>更容易实现</p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ol>
<li>直接通信需要每个进程明确命名接受者或发送者</li>
<li>间接通信通过邮箱或端口发送和接收消息</li>
</ol>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>阻塞（同步）与非阻塞（异步）</p>
<h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><ul>
<li>零容量：没有缓冲的消息系统，只能阻塞发送</li>
<li>有限容量：自动缓冲，线路满时阻塞发送</li>
<li>无限容量：自动缓冲</li>
</ul>
<h1 id="线程（CPU使用的基本单元）"><a href="#线程（CPU使用的基本单元）" class="headerlink" title="线程（CPU使用的基本单元）"></a>线程（CPU使用的基本单元）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由线程ID、程序计数器、寄存器集合和栈组成，与统一进程的其他线程共享代码段、数据段和其他操作系统资源。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>响应度高</li>
<li>资源共享</li>
<li>经济</li>
<li>多处理器体系结构的利用：加强了并发功能</li>
</ul>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p><strong>用户线程</strong>受内核支持，而无需内核管理（创建快）；<strong>内核线程</strong>有操作系统直接管理和支持。</p>
<h3 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h3><p>将许多用户级线程映射到一个内核线程，效率比较高。</p>
<p>但是任意时刻只有一个线程能访问内核，因此也无法运行在多处理器上。</p>
<h3 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h3><p>将每个用户线程映射到一个内核线程。</p>
<p>在一个线程执行阻塞系统调用时，能允许另一个线程继续执行。可以让多个线程并行地运行在多处理器系统上。</p>
<p>每有一个用户线程就要创建一个相应的内核线程，因此限制了系统所支持的线程数量。</p>
<h3 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h3><p>多路复用了许多用户线程到同样数量或更小数量的内核上。</p>
<p>开发人员可创建任意多的用户线程，并且相应内核线程能在多处理器上并发执行；而且当一个线程执行阻塞系统调用时，内核能调度另一个线程来执行。</p>
<h3 id="二级模型（混合模型）"><a href="#二级模型（混合模型）" class="headerlink" title="二级模型（混合模型）"></a>二级模型（混合模型）</h3><p>多对多模型的变种，在多路复用的同时允许将一个用户线程绑定到某个内核线程上。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>linux系统同时提供了fork() 和clone() 创建线程。</li>
<li>linux系统并不区分进程和线程，统一称之为任务。</li>
</ul>
<h1 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h1><p>调度对象：进程（以及线程）</p>
<p>从就绪进程队列中选择一个进程。</p>
<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><h3 id="CPU-I-O区间周期"><a href="#CPU-I-O区间周期" class="headerlink" title="CPU-I/O区间周期"></a>CPU-I/O区间周期</h3><p>进程执行由CPU执行和I/O等待周期组成，进程在这两个状态之间切换。</p>
<p>进程执行从CPU区间开始，在这之后是I/O区间。最终，最后的CPU区间通过系统请求终止执行。</p>
<h3 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h3><h3 id="抢占调度"><a href="#抢占调度" class="headerlink" title="抢占调度"></a>抢占调度</h3><p>CPU调度决策可在如下4种环境下发生：</p>
<ul>
<li>当一个进程从运行状态切换到等待状态</li>
<li>当一个进程从运行状态切换到就绪状态</li>
<li>当一个进程从等待状态切换到就绪状态</li>
<li>当一个进程终止时</li>
</ul>
<p>对于第1和第4种情况，没有选择而只有调度，一个新进程必须被执行。</p>
<p>当调度只能发生在第1和第4两种情况下时，称调度方案是非抢占的或协作的；否则，称调度方案是抢占的。</p>
<h3 id="分派程序"><a href="#分派程序" class="headerlink" title="分派程序"></a>分派程序</h3><p>用来将CPU的控制交给由短期调度程序选择的进程，功能包括：</p>
<ul>
<li>切换上下文</li>
<li>切换到用户模式</li>
<li>跳转到用户程序的合适位置，以重新启动进程</li>
</ul>
<p>分派程序在每次进程切换时都要使用。分派程序停止一个进程而启动另一个所要花费的时间称为分派延迟。</p>
<h2 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h2><ul>
<li>CPU使用率：需要使CPU尽可能忙。40%（轻负荷系统）~90%（重负荷系统）</li>
<li>吞吐量（一个时间单元内完成进程的数量）</li>
<li>周转时间：从进程提交到进程完成的时间段。所有时间段之和，包括等待进入内存、在就绪队列中等待、在CPU上执行和IO执行</li>
<li>等待时间：在就绪队列中等待所划分时间之和</li>
<li>响应时间：对交互系统，从提交请求到产生第一响应的时间。</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先到先服务调度算法（FCFS）"><a href="#先到先服务调度算法（FCFS）" class="headerlink" title="先到先服务调度算法（FCFS）"></a>先到先服务调度算法（FCFS）</h3><ul>
<li>实现简单</li>
<li>平均等待时间通常不是最小，受进程CPU区间时间变化影响大</li>
<li>存在<strong>护航效果</strong>，即所有其他进程等待一个大进程释放CPU，导致CPU和设备的使用率低下</li>
<li>非抢占式</li>
</ul>
<h3 id="最短作业优先调度（SJF）"><a href="#最短作业优先调度（SJF）" class="headerlink" title="最短作业优先调度（SJF）"></a>最短作业优先调度（SJF）</h3><ul>
<li>将每个进程与其下一个CPU区间段相关联。当CPU空闲时，它会赋给具有最短CPU区间的进程。</li>
<li>理论上最优的方法</li>
<li>困难在于如何知道下一个CPU区间的长度</li>
<li>可以是抢占的或非抢占的，抢占SJF算法称为<strong>最短剩余时间优先调度</strong></li>
</ul>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><ul>
<li>每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU。</li>
<li>优先级可以通过内部或者外部方式来定义</li>
<li>优先调度可以是抢占的或非抢占的</li>
<li>主要问题是<strong>无穷阻塞（饥饿）</strong>：低优先级进程无穷等待CPU，可以通过<strong>老化</strong>（逐渐增加在系统中等待很长时间的进程的优先级）解决</li>
</ul>
<h3 id="轮转法（RR）"><a href="#轮转法（RR）" class="headerlink" title="轮转法（RR）"></a>轮转法（RR）</h3><ul>
<li>定义一个较小时间单元，称为时间片。CPU调度程序循环就绪队列，为每个进程分配不超过一个时间片的CPU</li>
<li>如果当前运行进程的CPU区间比时间片要长，定时器会中断并产生操作系统中断，然后进行上下文切换，将进程加入到就绪队列的尾部。</li>
<li>平均等待时间较长</li>
<li>可抢占的</li>
<li>时间片太小，平均周转时间长，而且上下文切换的消耗大；时间片太大，RR有可能变成FCFS调度。80%的CPU时间应小于时间片。</li>
</ul>
<h3 id="多级队列调度"><a href="#多级队列调度" class="headerlink" title="多级队列调度"></a>多级队列调度</h3><ul>
<li>将就绪队列分成多个独立队列，一个进程被永久地分配到一个队列，每个队列有自己的调度算法</li>
<li>队列之间必须有调度，可以采用固定优先级抢占调度或者划分时间片。</li>
<li>低调度开销</li>
<li>不够灵活</li>
</ul>
<h3 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h3><ul>
<li>允许进程在队列之间移动。如果进程使用了过多CPU时间，那么它会被转移到更低优先级队列。此外，在较低优先级队列中等待较长时间的进程会被转移到更高优先级队列。</li>
<li>最通用也是最复杂的CPU调度算法</li>
</ul>
<h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>非对称多处理</code>和<code>对称多处理（SMP）</code></p>
<h3 id="处理器亲和性"><a href="#处理器亲和性" class="headerlink" title="处理器亲和性"></a>处理器亲和性</h3><p>由于使缓存无效或者重新构建的代价高，所以大多数SMP系统会努力使在同一个处理器上运行。</p>
<p><code>软亲和性</code>指操作系统具有设法让一个进程保持在同一个处理器上运行的策略，但不能做任何保证；与此相对地，<code>硬亲和性</code>则会允许进程指定它不逊于移至其他处理器上。</p>
<h3 id="负载平衡"><a href="#负载平衡" class="headerlink" title="负载平衡"></a>负载平衡</h3><p>设法将工作负载平均地分配到SMP系统中所有的处理器上。负载平衡有两种方法：<code>push migration</code><em>（由一个特定的任务将进程从超载处理器移到空闲或不太忙的处理器上）</em>和<code>pull migration</code><em>（空闲处理器主动从忙处理器上获取任务）</em>，这两种方法不互相排斥。</p>
<p>负载平衡常会抵消处理器亲和性的优点</p>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h2><p>通常出现在全局变量和共享数据时。</p>
<p>临界区问题是设计一个以便进程协作的协议，每个进程必须在<code>进入区</code>请求进入<code>临界区</code>，<code>临界区</code>之后有<code>退出区</code>，其他代码为<code>剩余区</code>。</p>
<p>解答必须满足以下三项要求：</p>
<ul>
<li>互斥：同一时刻只有一个进程能在自己的临界区内执行。</li>
<li>前进：如果没有进程在其临界区内执行且有进程需进入临界区，那么只有那些不在剩余区内执行的进程可参加选择，以确定谁能下一个进入临界区，且这种选择不能无限推迟。</li>
<li>有限等待：从一个进程做出进入临界区的请求，直到该请求允许为止，其它进程允许进入其临界区的次数有上限。</li>
</ul>
<h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    flag[i] = TRUE;</span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="keyword">while</span>(flag[j] &amp;&amp; turn == j);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">    </span><br><span class="line">    flag[i] = FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剩余区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​                                                               Peterson算法中进程P[i]的结构</p>
<p>其中turn表示哪个进程可以进入临界区，flag表示哪个进程想要进入临界区。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量S是一个整数变量，除了初始化，它只能通过两个标准原子操作来访问：<code>wait()</code>和<code>signal()</code>，或者称为P操作和V操作。</p>
<p>计数信号量的值域不受限制，而二进制信号量的值只能为0或1，有的系统也将二进制信号量称为互斥锁。</p>
<p>但是信号量的主要缺点是忙等待。当一个进程位于临界区内时，任何其他试图进入临界区的进程都必须连续地循环。忙等待浪费了CPU时钟。这种类型的信号量称为<code>自旋锁</code>。<em>（优点：锁的占用时间短时，进程在等待锁时不需要进行上下文切换）</em></p>
<h3 id="对信号量进行重新定义"><a href="#对信号量进行重新定义" class="headerlink" title="对信号量进行重新定义"></a>对信号量进行重新定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">list</span>;</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure>
<p>当一个进程必须等待信号量时，就加入到进程链表上。</p>
<h3 id="操作wait-的定义："><a href="#操作wait-的定义：" class="headerlink" title="操作wait()的定义："></a>操作wait()的定义：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S)</span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// add this process to S-&gt;list</span></span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>block()会挂起调用它的进程</p>
<h3 id="操作signal-的定义"><a href="#操作signal-的定义" class="headerlink" title="操作signal()的定义"></a>操作signal()的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">signal(semaphore *S)</span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// remove a process P from S-&gt;list</span></span><br><span class="line">        wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wakeup(P)重新启动阻塞进程P的执行</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁的根本原因"><a href="#死锁的根本原因" class="headerlink" title="死锁的根本原因"></a>死锁的根本原因</h2><ul>
<li>资源不足</li>
<li>进程推进顺序不当</li>
</ul>
<h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ul>
<li>互斥：至少有一个资源是非共享的</li>
<li>占有并等待：一个进程必须至少占有至少一个资源并等待另一个被其他进程占有的资源</li>
<li>非抢占：资源不能被抢占</li>
<li>循环等待：P[0]等待的资源被P[1]占有，…，P[n]等待的资源被P[0]占有</li>
</ul>
<p><strong>四个条件必须同时满足才会出现死锁！</strong></p>
<h2 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h2><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>死锁预防是一组通过限制申请资源的方法来保证至少一个必要条件不成立的方法。</p>
<p>但是设备使用率和系统吞吐率低</p>
<h5 id="互斥（通常不能否定）"><a href="#互斥（通常不能否定）" class="headerlink" title="互斥（通常不能否定）"></a>互斥（通常不能否定）</h5><h5 id="占有并等待"><a href="#占有并等待" class="headerlink" title="占有并等待"></a>占有并等待</h5><p>当一个进程申请一个资源时，必须不能占有其他资源。</p>
<ul>
<li>进程在执行前就申请并获得所有资源</li>
<li>先申请并使用一些资源，之后申请其他资源时释放之前的资源</li>
</ul>
<p>但是这样资源利用率低，并且可能发生饥饿</p>
<h5 id="非抢占"><a href="#非抢占" class="headerlink" title="非抢占"></a>非抢占</h5><p>如果一个进程占有资源并申请另一个不能立即分配的资源，那么其现已分配的资源都可被抢占</p>
<h5 id="循环等待"><a href="#循环等待" class="headerlink" title="循环等待"></a>循环等待</h5><p>对所有资源类型进行完全排序，并要求每个进程按递增顺序来申请资源。即当一个进程申请队列前端的资源时，它必须先释放所有靠后的资源</p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>动态地检测资源分配状态以确保循环等待条件不可能成立。资源分配状态是由可用资源和已分配资源以及进程最大需求所决定的。</p>
<h4 id="资源分配图算法"><a href="#资源分配图算法" class="headerlink" title="资源分配图算法"></a>资源分配图算法</h4><p>适用于每种资源类型<strong>只有一个实例</strong>的资源分配图</p>
<p>除了申请边和分配边之外，加入一种新的<code>需求边</code>，需求边P<sub>i </sub>-&gt; R<sub>j</sub>表示进程P<sub>i</sub>可能在将来某个时刻申请资源R<sub>j</sub>，与申请边方向相同，用虚线表示。</p>
<p>只有在将申请边P<sub>i </sub>-&gt; R<sub>j</sub>变成分配边R<sub>j </sub>-&gt; P<sub>i</sub>而不会导致资源分配图成环时才允许申请。</p>
<h4 id="银行家算法（重要！）"><a href="#银行家算法（重要！）" class="headerlink" title="银行家算法（重要！）"></a>银行家算法（重要！）</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><ul>
<li>Available[m]：每种资源的现有实例的数量</li>
<li>Max[n][m]：每个进程的最大需求，Max[i][j] = k 表示进程P<sub>i</sub>最多可申请K个R<sub>j</sub>的实例</li>
<li>Allocation[n][m]：每个进程已经分配的资源类型的实例</li>
<li>Need[n][m]：每个进程还需要的剩余的资源。Need[i][j] = Max[i][j] - Allocation[i][j]</li>
</ul>
<h5 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h5><p>用来确定计算机当前是否处于安全状态</p>
<ol>
<li><p>设Work[m] 和Finish[n]，Work初始化为Available，Finish初始化为FALSE矩阵。</p>
</li>
<li><p>查找一个满足如下条件的i：</p>
<ol>
<li>Finish[i] = FALSE</li>
<li>Need[i] &lt;= Work</li>
</ol>
<p>查找到结果继续进行；反之跳转至第四步</p>
</li>
<li><p>Work = Work + Allocation[i]</p>
<p>Finish[i] = TRUE</p>
<p>重新执行第2步</p>
</li>
<li><p>Finish为TRUE时，系统安全</p>
</li>
</ol>
<p>这个算法可能需要m * n^2数量级的操作</p>
<h5 id="资源请求算法"><a href="#资源请求算法" class="headerlink" title="资源请求算法"></a>资源请求算法</h5><p>设Request[i]是进程P<sub>i</sub>的请求向量。</p>
<ol>
<li><p>如果Request[i] &lt;= Need[i]，继续进行；否则出错：进程P<sub>i</sub>请求的资源超过了最大请求</p>
</li>
<li><p>如果Request[i] &lt;= Available，继续进行；否则进程P<sub>i</sub>必须等待，因为目前没有可用资源</p>
</li>
<li><p>Available = Available - Request[i]</p>
<p>Allocation[i] = Allocation[i] + Request[i]</p>
<p>Need[i] = Need[i] - Request[i]</p>
<p>如果这样产生的资源分配状态是安全的，那么交易完成，进程P<sub>i</sub>分配到所需资源。如果不安全，那么进程P<sub>i</sub>必须等待Request[i]并恢复到原来的资源分配状态</p>
</li>
</ol>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>每个资源类型只有单个实例时：当且仅当等待图中有一个环，系统中存在死锁。</p>
<p>每个资源类型可有多个实例时：银行家算法的变种。</p>
<h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><h4 id="进程终止-1"><a href="#进程终止-1" class="headerlink" title="进程终止"></a>进程终止</h4><ul>
<li>终止所有死锁进程</li>
<li>一次只终止一个进程直到取消死锁循环为止</li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/04/09/操作系统概念复习总结/">操作系统概念复习总结</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">uuweidy</a></p>
        <p><span>发布时间:</span>2019-04-09, 10:03:11</p>
        <p><span>最后更新:</span>2019-05-14, 20:53:08</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/04/09/操作系统概念复习总结/" title="操作系统概念复习总结">http://uuweidy.github.io/2019/04/09/操作系统概念复习总结/</a>
            <span class="copy-path" data-clipboard-text="原文: http://uuweidy.github.io/2019/04/09/操作系统概念复习总结/　　作者: uuweidy" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/04/28/Android-Studio的环境搭建/">
                    Android Studio的环境搭建
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/03/27/数据结构与算法复习总结/">
                    数据结构与算法复习总结
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#导论"><span class="toc-number">1.</span> <span class="toc-text">导论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机系统体系结构"><span class="toc-number">1.1.</span> <span class="toc-text">计算机系统体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单处理器系统"><span class="toc-number">1.1.1.</span> <span class="toc-text">单处理器系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多处理器系统"><span class="toc-number">1.1.2.</span> <span class="toc-text">多处理器系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#非对称多处理"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">非对称多处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对称多处理（SMP）"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">对称多处理（SMP）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集群系统"><span class="toc-number">1.1.3.</span> <span class="toc-text">集群系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统结构"><span class="toc-number">2.</span> <span class="toc-text">操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统服务"><span class="toc-number">2.1.</span> <span class="toc-text">操作系统服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统调用"><span class="toc-number">2.2.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#系统调用类型"><span class="toc-number">2.2.1.</span> <span class="toc-text">系统调用类型*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机"><span class="toc-number">2.3.</span> <span class="toc-text">虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建虚拟机的原因"><span class="toc-number">2.3.1.</span> <span class="toc-text">创建虚拟机的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优点"><span class="toc-number">2.3.2.</span> <span class="toc-text">优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程（CPU资源分配的基本单元）"><span class="toc-number">3.</span> <span class="toc-text">进程（CPU资源分配的基本单元）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">3.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程状态"><span class="toc-number">3.1.1.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程控制块（PCB，进程存在的唯一标志）"><span class="toc-number">3.1.2.</span> <span class="toc-text">进程控制块（PCB，进程存在的唯一标志）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">3.1.3.</span> <span class="toc-text">线程*</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程调度"><span class="toc-number">3.2.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调度队列"><span class="toc-number">3.2.1.</span> <span class="toc-text">调度队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调度程序"><span class="toc-number">3.2.2.</span> <span class="toc-text">调度程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上下文切换"><span class="toc-number">3.2.3.</span> <span class="toc-text">上下文切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程操作"><span class="toc-number">3.3.</span> <span class="toc-text">进程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程创建"><span class="toc-number">3.3.1.</span> <span class="toc-text">进程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程终止"><span class="toc-number">3.3.2.</span> <span class="toc-text">进程终止</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程间通信"><span class="toc-number">3.4.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共享内存"><span class="toc-number">3.4.1.</span> <span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息传递"><span class="toc-number">3.4.2.</span> <span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#命名"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">缓冲</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程（CPU使用的基本单元）"><span class="toc-number">4.</span> <span class="toc-text">线程（CPU使用的基本单元）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程模型"><span class="toc-number">4.2.</span> <span class="toc-text">多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多对一模型"><span class="toc-number">4.2.1.</span> <span class="toc-text">多对一模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一对一模型"><span class="toc-number">4.2.2.</span> <span class="toc-text">一对一模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多对多模型"><span class="toc-number">4.2.3.</span> <span class="toc-text">多对多模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二级模型（混合模型）"><span class="toc-number">4.2.4.</span> <span class="toc-text">二级模型（混合模型）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其它"><span class="toc-number">4.3.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CPU调度"><span class="toc-number">5.</span> <span class="toc-text">CPU调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念-1"><span class="toc-number">5.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-I-O区间周期"><span class="toc-number">5.1.1.</span> <span class="toc-text">CPU-I/O区间周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU调度程序"><span class="toc-number">5.1.2.</span> <span class="toc-text">CPU调度程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抢占调度"><span class="toc-number">5.1.3.</span> <span class="toc-text">抢占调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分派程序"><span class="toc-number">5.1.4.</span> <span class="toc-text">分派程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调度准则"><span class="toc-number">5.2.</span> <span class="toc-text">调度准则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调度算法"><span class="toc-number">5.3.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#先到先服务调度算法（FCFS）"><span class="toc-number">5.3.1.</span> <span class="toc-text">先到先服务调度算法（FCFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最短作业优先调度（SJF）"><span class="toc-number">5.3.2.</span> <span class="toc-text">最短作业优先调度（SJF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优先级调度"><span class="toc-number">5.3.3.</span> <span class="toc-text">优先级调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#轮转法（RR）"><span class="toc-number">5.3.4.</span> <span class="toc-text">轮转法（RR）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多级队列调度"><span class="toc-number">5.3.5.</span> <span class="toc-text">多级队列调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多级反馈队列调度"><span class="toc-number">5.3.6.</span> <span class="toc-text">多级反馈队列调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多处理器调度"><span class="toc-number">5.4.</span> <span class="toc-text">多处理器调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-number">5.4.1.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理器亲和性"><span class="toc-number">5.4.2.</span> <span class="toc-text">处理器亲和性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#负载平衡"><span class="toc-number">5.4.3.</span> <span class="toc-text">负载平衡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程同步"><span class="toc-number">6.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#临界区问题"><span class="toc-number">6.1.</span> <span class="toc-text">临界区问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Peterson算法"><span class="toc-number">6.2.</span> <span class="toc-text">Peterson算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号量"><span class="toc-number">6.3.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对信号量进行重新定义"><span class="toc-number">6.3.1.</span> <span class="toc-text">对信号量进行重新定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作wait-的定义："><span class="toc-number">6.3.2.</span> <span class="toc-text">操作wait()的定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作signal-的定义"><span class="toc-number">6.3.3.</span> <span class="toc-text">操作signal()的定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#死锁"><span class="toc-number">7.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁的根本原因"><span class="toc-number">7.1.</span> <span class="toc-text">死锁的根本原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁产生的必要条件"><span class="toc-number">7.2.</span> <span class="toc-text">死锁产生的必要条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁的处理方法"><span class="toc-number">7.3.</span> <span class="toc-text">死锁的处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁预防"><span class="toc-number">7.3.1.</span> <span class="toc-text">死锁预防</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#互斥（通常不能否定）"><span class="toc-number">7.3.1.0.1.</span> <span class="toc-text">互斥（通常不能否定）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#占有并等待"><span class="toc-number">7.3.1.0.2.</span> <span class="toc-text">占有并等待</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#非抢占"><span class="toc-number">7.3.1.0.3.</span> <span class="toc-text">非抢占</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#循环等待"><span class="toc-number">7.3.1.0.4.</span> <span class="toc-text">循环等待</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁避免"><span class="toc-number">7.3.2.</span> <span class="toc-text">死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#资源分配图算法"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">资源分配图算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#银行家算法（重要！）"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">银行家算法（重要！）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数据结构"><span class="toc-number">7.3.2.2.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#安全性算法"><span class="toc-number">7.3.2.2.2.</span> <span class="toc-text">安全性算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#资源请求算法"><span class="toc-number">7.3.2.2.3.</span> <span class="toc-text">资源请求算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁检测"><span class="toc-number">7.3.3.</span> <span class="toc-text">死锁检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁恢复"><span class="toc-number">7.3.4.</span> <span class="toc-text">死锁恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进程终止-1"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">进程终止</span></a></li></ol></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>





    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/04/28/Android-Studio的环境搭建/" title="上一篇: Android Studio的环境搭建">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/03/27/数据结构与算法复习总结/" title="下一篇: 数据结构与算法复习总结">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/14/操作系统概念复习总结-2/">操作系统概念复习总结(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/28/Android-Studio的环境搭建/">Android Studio的环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/09/操作系统概念复习总结/">操作系统概念复习总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/27/数据结构与算法复习总结/">数据结构与算法复习总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/26/KMP算法学习总结/">KMP算法学习总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/04/2018下半年总结/">2018下半年总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/05/PPT学习笔记/">PPT学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/2018年暑假总结/">2018年暑假总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/29/感冒了/">感冒了</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/27/为以后做的准备/">为以后做的准备</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/25/My-First-Blog/">My First Blog</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/25/hello-world/">Hello World</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 uuweidy
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 3;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        $("a").attr("target", "_blank");
        $("#scroll a, #toc a").removeAttr("target");
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>